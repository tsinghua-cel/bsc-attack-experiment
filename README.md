# bsc-attack-experiment

## Introduction

This repository contains the implementation and artifacts for the paper:  
**[USENIX25] Does Finality Gadget Finalize Your Block? A Case Study of Binance Consensus**. 

The paper analyzes the consensus protocol of BNB Smart Chain (BSC). Since mid-2023, BSC has integrated a *Fast Finality (FF)* mechanism, where validators vote to finalize block order. BSC claims that its FF mechanism can finalize blocks in O(1) time, simultaneously reducing latency and improving stability. The paper presents three attacks, showing BSC fails to finalize blocks in constant time and may even simply fail to achieve liveness.

This repository is intended to support both **functionality** and **reproducibility** evaluation, enabling reviewers and researchers to replicate all key experiments and validate the claims presented in the paper.

This repository provides an extended and actively maintained version of our artifact archived at [Zenodo](https://zenodo.org/records/15552871).

## 🚀 Quick Access 
All raw data and logs are available in the `/test-data/` directory.

| **Output Results (TXT)**               | **Chain Data (ZIP)**                              | **Description**                                                                 |
|----------------------------------------|-------------------------------------------------|---------------------------------------------------------------------------------|
| `attack-1-reward.txt`                  | `node-attack-1-reward.zip`                      | Reward details for Attack 1.                                                   |
| `attack-1.txt`                         | `node-attack-1.zip`                             | Details and logs for Attack 1.                                                  |
| `attack-2-reward.txt`                  | `node-attack-2-reward.zip`                      | Reward details for Attack 2.                                                   |
| `attack-2.txt`                         | `node-attack-2.zip`                             | Details and logs for Attack 2.                                                  |
| `attack-3-bootnode-25.txt`             | `node-attack-3-bootnode-25.zip`                 | Details and logs for Attack 3: using bootnode-based connection with a 25ms delay.                  |
| `attack-3-bootnode-50-reward.txt`      | `node-attack-3-bootnode-50-reward.zip`          | Reward details for Attack 3: using bootnode-based connection with a 50ms delay.                   |
| `attack-3-bootnode-50.txt`             | `node-attack-3-bootnode-50.zip`                 | Details and logs for Attack 3: using bootnode-based connection with a 50ms delay.                  |
| `attack-3-bootnode-75.txt`             | `node-attack-3-bootnode-75.zip`                 | Details and logs for Attack 3: using bootnode-based connection with a 75ms delay.                  |
| `attack-3-staticnode-25.txt`           | `node-attack-3-staticnode-25.zip`               | Details and logs for Attack 3: using full connection with a 25ms delay.                |
| `attack-3-staticnode-50-reward.txt`    | `node-attack-3-staticnode-50-reward.zip`        | Reward details for Attack 3: using full connection with a 50ms delay.                 |
| `attack-3-staticnode-50.txt`           | `node-attack-3-staticnode-50.zip`               | Details and logs for Attack 3: using full connection with a 50ms delay.                |
| `attack-3-staticnode-75.txt`           | `node-attack-3-staticnode-75.zip`               | Details and logs for Attack 3: using full connection with a 75ms delay.                |
| `normal-reward.txt`                    | `node-normal-reward.zip`                        | Reward details for benchmark.                                           |

## 📦 Recommended Setup: Docker
We strongly recommend using our prebuilt Docker images to reproduce all results reliably and efficiently.

### Prerequisites

- Docker Engine ≥ **v20.10**
- Memory: **16 GB+** recommended

### Running attack 1 
```bash
touch 1.txt && docker run -it --rm -v ./1.txt:/app/query/21.txt erick785/bsc-attack-1:latest
```
### Running attack 2
```bash
touch 2.txt && docker run -it --rm -v ./2.txt:/app/query/21.txt erick785/bsc-attack-2:latest
```

### Running attack 3 (bootnode connection mode)
```bash
touch 3.1.txt && docker run -it --rm -v ./3.1.txt:/app/query/21.txt -e DELAY_INTERVAL_MS=25 erick785/bsc-attack-3-bootnode:latest
```

### Running attack 3 (full connection mode)
```bash
touch 3.2.txt && docker run -it --rm -v ./3.2.txt:/app/query/21.txt -e DELAY_INTERVAL_MS=25 erick785/bsc-attack-3-staticnode:latest
```

**Note:** The results generated by the Docker container will be saved to the file 3.1.txt. Notably, the DELAY_INTERVAL_MS field can be set to 25, 50, or 75, indicating three separate experiments for the bootnode mode. 

## 🛠️ Optional: Manual Build & Execution

We also provide a fully manual setup method for users or reviewers who prefer to inspect and customize the testing environment (See [Appendix](#appendix)).

##  🧪 Attack Success Criteria

Each line in the output file (e.g., `1.txt`, `2.txt`, `3.1.txt`, etc.) is a comma-separated triple: (`LatestBlock`), (`FinalizedBlock`), (`Attested`).

Data field definitions
 **Field Name**                              | **Description**                                                                 |
|-------------------------------------------------|---------------------------------------------------------------------------------|
| The latest block height (`LatestBlock`)                      | The number of the latest block that has been generated by the current node.    |
 Finalized block height (`FinalizedBlock`)                    | Block number that has been finalized.    |
| Attestation of block header (`Attested`)                    | `true` means that the block received a vote attestation, `false` means that it did not.    |

 > \* All attacks are triggered at block height **250** unless otherwise noted.


### For attack 1

**Objective:**  
Demonstrate that BSC’s FF mechanism becomes sluggish under attack, slowing finalization but not entirely failing.

**Success indicators:**
-   Before slot 250 (From 210-250): Finalized block always lags 2 blocks behind the latest block (normal behavior).
-   After slot 250: Finalized block height stops increasing for multiple slots.
-   Eventually: Finalization resumes after a long stall.
    
**Sample pattern:**

```
...
247,245,true
248,246,true
249,247,true
250,248,true # Latest block height is 250. Starting attack.
251,248,false # Finalization stops growing
252,248,false
253,248,false
...
266,248,false
267,248,false
268,248,true
269,267,true
270,268,true # Finalized blocks catch up to 268, indicating a gradual recovery of consensus 
271,269,true
272,269,false
273,269,false
274,269,false
...
289,270,false
290,288,true
291,289,true
...
```

###  For attack 2


**Objective:**  
Show that the finalization process halts completely after attack launch.

**Success Indicators:**

-   After slot 250: Finalized block height remains **frozen** at its pre-attack value (e.g., 248).
-   No future blocks reach finality during the remainder of the test.   

**Sample Pattern:**
```
...
248,246,true
249,247,true
250,248,true # The last normal finalized block height before the attack was 248
251,248,false # After the attack started, the finalized block was briefly boosted to 248
252,248,false # Subsequent blocks finalize block height stagnation at 248
253,248,false
254,248,false
255,248,false
256,248,false
257,248,true
...
274,248,false
275,248,false
276,248,false
278,248,false
279,248,false
280,248,false
281,248,false
...

```

**Note:** This experiment is probabilistic. The exact data may vary across runs. However, the observed trend remains consistent: before the attack is launched, the difference between the latest block height and the finalized block height consistently stays at 2(e.g., [247,245], [248, 246], [249, 247]..). After initiating the attack at slot 250, this gap begins to widen. The finality of blocks no longer progresses in step with the increasing latest block height. 

###  For attack 3

**Objective:**  
Demonstrate that FF can be stalled for an extended period.

**Success Indicators (for each delay setting):**

-   After attack start: Finalized block height stops increasing while the latest block keeps advancing.
-   Eventually: Finalized block resumes increasing but with a noticeable delay.
    
**Sample Pattern:**
```
...
438,429,false
439,429,false
440,429,false
441,429,false
442,429,false
443,429,false
444,429,false
445,429,false
446,429,false
447,429,false
448,429,false
449,429,false
450,429,false # At block 450, the finalized block height remains 429 (21 blocks delayed)  
451,429,false
452,429,false
453,429,false
454,429,false
455,429,false
456,429,false
457,429,false
458,429,false
459,429,false
460,429,false
461,429,false
462,429,false
463,429,false
464,429,false
465,429,false
466,429,false
467,429,false
468,429,false
469,429,false
470,429,false
471,429,false
472,429,false
473,429,true
474,429,false
475,429,true
476,474,true # After a delay, the `finalized block` starts catching up (`finalized block` height is the height of the `latest block` - 2) 
477,474,false
478,474,true
479,477,true
480,478,true
481,479,true
482,480,true
...
```
**Note:** This experiment is probabilistic. The exact data may vary from run to run. However, the observed trend remains consistent: After launching attack-III, the finalized blocks no longer increase in synchronization with the latest blocks, but rather increase in a delayed manner.

## 💻 Source Code

-   BSC base (v1.4.16): [https://github.com/bnb-chain/bsc/tree/v1.4.16](https://github.com/bnb-chain/bsc/tree/v1.4.16)

	  - attack 1 code : ./code/attack-1-code.zip
	  - attack 2 code : ./code/attack-2-code.zip
	  - attack 3 code : ./code/attack-3-bootnode-code.zip
	  - attack 3 code : ./code/attack-3-staicnode-code.zip
    
-   Node deployment script: [https://github.com/bnb-chain/node-deploy](https://github.com/bnb-chain/node-deploy)

## 📄Appendix
This section outlines the complete manual installation process, including environment setup, dependency installation, and attack execution using raw scripts and source code.

> ⚠️ **Before you begin**, please ensure the following software and system packages are installed on your local machine:

- Ubuntu 20.04/22.04
- nodejs: 18.20.2 
- npm: 6.14.6
- go: 1.18+
- python3: 3.12+
- docker: 27.5.1
- foundry: 1.1.0
- poety: 2.0.0
- jq: 1.7

### Setup steps
1. Unzip and enter the project directory
```bash
unzip node-deploy.zip
cd node-deploy
```
2. Create and activate a virtual environment
```
# Create the virtual environment (if the venv package is not installed)
python3 -m venv path/to/venv

# Create virtual environments
apt install python3.12-venv

# Activate the virtual environment
source path/to/venv/bin/activate
```
3. Install dependencies
```
chmod +x install-dev.sh
sudo ./install-dev.sh
pip3 install -r requirements.txt
```

4. compile the geth binary, and place it in the node-deploy/bin/ folder
```bash
unzip ./code/attack-1-code.zip 
cd attack-1-code && make geth
unzip node-deploy.zip
mv attack-1-code/build/bin/geth node-deploy/bin/geth
```
### Launching attack simulation
1. Start attack

```bash
# attack 1 and attack 2
bash -x ./bsc_cluster.sh reset # will reset the cluster and start

# attack 3
# Set delay to 25ms (DELAY_INTERVAL_MS can be adjusted to 25, 50, 75)
export DELAY_INTERVAL_MS=25 && bash -x ./bsc_cluster.sh reset
```

2. Start the monitoring script

```bash
cd query && go run main.go --node=21
```
> Notice: The monitoring data will be exported to the query/21.txt file.

## Contribution
- For questions or bug reports, please open a GitHub issue in this repository.
